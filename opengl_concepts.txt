This file explains the OpenGL and GLUT concepts used in the `main.cpp` file of the Snake 3D project.

### 1. GLUT (OpenGL Utility Toolkit)

- **Where:** Used throughout `main.cpp`, especially in `main()`, `display()`, `reshape()`, `keyboard()`, `specialKeys()`, and `update()`.
- **Why:** GLUT is used to create and manage the window, handle user input (keyboard), and set up the main event loop for rendering and game logic updates. It simplifies the process of creating a basic OpenGL application.
- **How:**
    - `glutInit(&argc, argv)`: Initializes the GLUT library.
    - `glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)`: Configures the display mode. `GLUT_DOUBLE` enables double buffering for smooth animation, `GLUT_RGB` sets the color mode to RGB, and `GLUT_DEPTH` enables a depth buffer for correct 3D rendering.
    - `glutInitWindowSize(800, 600)` and `glutCreateWindow("...")`: Create the application window with a specific size and title.
    - `glutDisplayFunc(display)`: Registers the `display` function to be called whenever the window needs to be redrawn.
    - `glutReshapeFunc(reshape)`: Registers the `reshape` function to be called when the window is resized.
    - `glutSpecialFunc(specialKeys)` and `glutKeyboardFunc(keyboard)`: Register callback functions to handle keyboard input (arrow keys and regular keys).
    - `glutTimerFunc(150, update, 0)`: Sets a timer that calls the `update` function periodically, driving the game's animation and logic.
    - `glutMainLoop()`: Starts the main event processing loop, which listens for events and calls the registered callbacks.
    - `glutSwapBuffers()`: In the `display` function, this swaps the front and back buffers to show the newly rendered frame.

### 2. Primitives and Basic Drawing

- **Where:** `drawScene()`, `drawTexturedWall()`, `drawTexturedCube()`, `drawSnakeHead()`, `drawApple()`, `drawBackground()`.
- **Why:** To draw the fundamental geometric shapes (quadrilaterals, lines) that make up all the objects in the game.
- **How:**
    - `glBegin(GL_QUADS)` and `glEnd()`: These functions delimit a block of vertices that are interpreted as quadrilaterals (four-sided polygons). This is used to draw the ground, walls, and the cubes of the snake's body.
    - `glBegin(GL_LINES)` and `glEnd()`: Used to draw the apple's stem.
    - `glVertex3f(x, y, z)`: Specifies a single vertex in 3D space. These are called between `glBegin` and `glEnd` to define the shape.

### 3. Transformations and Matrix Manipulation

- **Where:** `display()`, `reshape()`, `drawTexturedWall()`, `drawSnakeSegment()`, `drawSnakeHead()`, `drawApple()`.
- **Why:** Transformations are essential for placing, rotating, and scaling objects in the 3D world. They are also used to set up the camera's viewpoint.
- **How:**
    - `glMatrixMode(GL_PROJECTION)`: Selects the projection matrix, which is used to define the viewing volume (how the 3D scene is projected onto the 2D screen).
    - `glMatrixMode(GL_MODELVIEW)`: Selects the modelview matrix, which is used for transforming the objects themselves (moving, rotating, scaling).
    - `glLoadIdentity()`: Resets the current matrix to the identity matrix, effectively removing any previous transformations.
    - `gluPerspective(fov, aspect, near, far)`: Sets up a perspective projection, creating a realistic sense of depth.
    - `gluLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ)`: Defines the camera's position (`eye`), where it's looking (`center`), and its orientation (`up`).
    - `glTranslatef(x, y, z)`: Moves the current object along the specified vector.
    - `glRotatef(angle, x, y, z)`: Rotates the current object by `angle` degrees around the specified axis.
    - `glScalef(x, y, z)`: Scales the current object.
    - `glPushMatrix()` and `glPopMatrix()`: These functions save and restore the current matrix. This is crucial for isolating transformations, so that moving or rotating one object doesn't affect subsequent objects.

### 4. Lighting

- **Where:** `init()`, `display()`, `drawScene()`.
- **Why:** Lighting is used to create a more realistic and three-dimensional appearance for the objects in the scene.
- **How:**
    - `glEnable(GL_LIGHTING)`: Enables lighting calculations for the scene.
    - `glEnable(GL_LIGHT0)`: Enables a specific light source (OpenGL supports multiple lights).
    - `glLightfv(GL_LIGHT0, property, value)`: Sets properties for the light, such as its `GL_POSITION`, `GL_AMBIENT` color, and `GL_DIFFUSE` color.
    - `glNormal3f(x, y, z)`: Defines the normal vector for a surface. The normal vector is perpendicular to the surface and is essential for OpenGL to calculate how light reflects off it.

### 5. Texturing

- **Where:** `loadTexture()`, `init()`, and all `draw...` functions that use textures.
- **Why:** Texturing applies a 2D image to the surface of a 3D model, adding detail and realism without increasing geometric complexity. This is used for the grass, walls, snake, and apple.
- **How:**
    - `glGenTextures(1, &textureID)`: Generates a unique ID for a new texture.
    - `glBindTexture(GL_TEXTURE_2D, textureID)`: Binds a texture, making it the active one for subsequent operations.
    - `glTexParameteri(param, value)`: Sets texture parameters, such as `GL_TEXTURE_WRAP_S`/`T` (how the texture repeats) and `GL_TEXTURE_MIN_FILTER`/`MAG_FILTER` (how the texture is rendered when scaled).
    - `glTexImage2D(...)`: Uploads the pixel data of the image (loaded from a file using the `stb_image` library) to the GPU.
    - `glTexCoord2f(s, t)`: Specifies the texture coordinate for a vertex. This maps a point on the 2D texture image to a point on the 3D polygon.
    - `glEnable(GL_TEXTURE_2D)`: Enables 2D texturing for the objects being drawn.

### 6. Depth Buffer (Z-Buffering)

- **Where:** `init()`, `display()`, `drawBackground()`, `drawGameOverScreen()`.
- **Why:** The depth buffer ensures correct rendering of the 3D scene by keeping track of the depth of each pixel. This prevents objects that are farther away from being drawn in front of closer objects.
- **How:**
    - `glEnable(GL_DEPTH_TEST)`: Enables the depth test.
    - `glutInitDisplayMode(... | GLUT_DEPTH)`: Requests a depth buffer when the window is created.
    - `glClear(GL_DEPTH_BUFFER_BIT)`: In the `display` function, this clears the depth buffer at the start of each frame, preparing it for the new scene.

### 7. 2D Drawing for HUD (Orthographic Projection)

- **Where:** `drawBackground()`, `drawHUD()`, `drawGameOverScreen()`.
- **Why:** To draw 2D elements like the background image, score, and "Game Over" text directly onto the screen, on top of the 3D scene.
- **How:**
    - The code temporarily switches from a 3D perspective projection to a 2D orthographic projection.
    - `glMatrixMode(GL_PROJECTION)`, `glPushMatrix()`, `glLoadIdentity()`: Saves the 3D projection and starts fresh.
    - `gluOrtho2D(0, 800, 0, 600)`: Sets up a 2D projection where the coordinates correspond directly to the window's pixel dimensions.
    - `glMatrixMode(GL_MODELVIEW)`, `glPushMatrix()`, `glLoadIdentity()`: Saves the 3D modelview matrix and resets it for 2D drawing.
    - `glRasterPos2f(x, y)` and `glutBitmapCharacter(...)`: Used to position and draw text on the screen.
    - `glPopMatrix()`: After drawing the 2D elements, the previous 3D projection and modelview matrices are restored to continue drawing the 3D scene.

### 8. Blending for Transparency

- **Where:** `drawGameOverScreen()`.
- **Why:** To create the semi-transparent black overlay for the "Game Over" screen.
- **How:**
    - `glEnable(GL_BLEND)`: Enables blending.
    - `glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)`: Sets the blending function, which is a standard formula for alpha blending (drawing a transparent color on top of an existing color).
    - `glColor4f(r, g, b, a)`: The `a` (alpha) component in the color determines its transparency (0.0 is fully transparent, 1.0 is fully opaque).
    - `glDisable(GL_BLEND)`: Disables blending after the transparent object has been drawn.
